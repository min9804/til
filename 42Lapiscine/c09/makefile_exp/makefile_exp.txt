-makefile_explain

소스파일을 컴파일을 하기위해서는 
gcc [옵션] [실행파일명] [소스파일명] 이 필요하다.

하지만 여러 파일을 컴파일 할 경우 각 소스 파일을 각각
.o 파일 오브젝트 파일로 만든 후 오브젝트 파일을 실행 파일로 만든다.

ex)
gcc -c hello.c
gcc -c main.c
gcc -o hello hello.o main.o

gcc -o hello hello.c main.c 처럼
소스파일로도 컴파일 할 수 있는데 왜 오브젝트 파일을 만들까?
소스 파일이 100개가 있는 경우 소스 파일로 컴파일 한다면
소스파일 한개에 문제가 생겼을 때 100개의 파일을 모두 다시 컴파일
해야한다. 이렇게 된다면 시간이 오래 걸리기 때문에 
각각의 오브젝트 파일을 만들어 놓고 수정할 소스가 생기면 수정후 
그 파일의 오브젝트 파일만 다시 만들면 된다.

위에 예 처럼 세줄을 쓰면서 컴파일 한다
너무 취찮으니까 만든 방법이 shellscript를 만들 수 있음

vim compile.sh파일

#!/bin/bash
gcc -c hello.c
gcc -c main.c
gcc -o hello hello.o main.o

chmod 755로 권한주기!
./copile.sh 하면 위에 3개의 명령어가 실행되면서 컴파일 된다.

하지만 shellscript를 작성해도 모든 소스파일을 오브젝트 파일로 만드는
과정을 거치게 된다. 이러면 또 시간이 오래 걸리기 때문에 이점이 없다.

이를 해결 하기 위해 makefile을 만들고 make프로그램을 이용한다.
make를 이용하면 변경된 소스만 오브젝트파일을 만들어 컴파일 하는
기능을 이용할 수 있다.



-Makefile 작성규칙

목표파일: 목표파일을 만드는데 필요한 구성요소들
(tab)	목표를 달성하기 위한 명령1
(tab)	목표를 달성하기 위한 명령2

//매크로 정의: Makdefile에 정의한 string으로 치환한다.
//명령어의 시작은 반드시 탭으로 시작한다.
//Dependency가 없는 target도 사용 가능하다.



-Make 예제

(타겟절)      (의존성, 종속항목)
hello_world : hello.o world.o main.o
	gcc -o hello_world hello.o world.o main.o (명령어)

hello.o : hello.c
	gcc -c -o hello.o hello.c

world.o : world.c
	gcc -c -o world.o world.c

main.o : main.c
	gcc -c -o main.o main.c

clean :			(더미타겟)
	rm *.o hello_world 

더미타겟은 파일을 생성하지 않는 개념적인 타겟으로 
make clean 명령하면 현재 디렉토리의 모든 object파일들과 생성된 실행
파일을 rm 명령어로 제거해 줍니다. 



-Makefile 매크로 사용

중복되는 파일 이름들을 특정 단어올 치환 하면 된다.

CC = gcc
CFLAGS = -Wall -Wextra -Werror
TARGET = hello_world

$(TARGET): hello.o world.o main.o
	$(CC) $(CFLGS) -o $(TARGET) hello.o world.o main.o

hello.o : hello.c
	$(CC) $(CFLGS) -c -o hello.o hello.c

world.o : world.c
	$(CC) $(CFLGS) -c -o world.o world.c

main.o : main.c
	$(CC) $(CFLGS) -c -o main.o main.c

clean :
	rm *.o hello_world

작성규칙 
-매크로를 참조 할 때는 소괄호나 중괄호 둘러싸고 앞에 ‘$’를 붙인다.
-탭으로 시작해서는 안되고 , :,=,#,”” 등은 매크로 이름에 사용할 수 없다.
-매크로는 반드시 치환될 위치보다 먼저 정의 되어야 한다.




-Makefile개선하기2: 내부 매크로 사용

CC = gcc
CFLAGS = -Wall -Wextra -Werror
TARGET = hello_world
OBJECTS = hello.o world.o main.o

all: $(TARGET)

$(TARGET): $(OBJECTS)
	     $(CC) $(CFLAGS) -o $@ $^

clean :
	rm *.o hello_world

1. gcc 컴파일러를 이용
2. 사소한 오류까지 출력
3. 최종 타겟 파일은 diary_exe
4. OBJECT 로 정의할 파일들은 hello.o world.o main.o
5. all 은 현재는 사용하지 않았지만 타겟 파일이 여러개 일때 사용됩니다.
6. 타겟 파일을 만들기 위해 OBJECT 들을 사용한다.( 단 OBJECT 파일이 
없다면 OBJECT 파일과 이름이 동일한 C파일을 찾아 OBJECT파일을 생성한다. )
7. gcc -o diary_exe memo.o main.o calendar.o과 동일
8. 더미타겟





-Makefile기호

$@ 현재 타겟의 이름
$^ 현재 타겟의 종속 항목 리스트
$< 타겟을 생성하기 위해 가장 왼쪽에 기술된 첫번째 오브젝트
$? 타겟을 생성하기 위해서 기술된 것들에 가장 최근에 변경된 오브젝트 파일


%.o: %.c
% 기호는 파일이름을 의미한다.

OBJS = $(SOURCES:.c=.o)
OBJS는 SOURC의 값을 할당받는다.
.c 파일이 .o파일로 변환된후에

all : $(TARGET)
all 옵션이 없는 경우 제일 첫번째 Target만 실행 시키고 종료
ex) TARGET 을 만드는 절이 밑에 있는 경우

-c 옵션은 object 파일을 생성하는 옵션이고,
-o 옵션은 생성 될 파일 이름을 지정하는 옵션입니다.

-o 옵션을 넣지 않아도 object 파일이름이 (c파일이름).o로 자동 생성 됩니다.
하지만 실행 파일 생성시 -o 옵션을 넣지 않으면 모든 파일이 a.out 
이라는 이름을 가지게 되므로 여러 개의 실행 파일을 생성해야 
할 때 효율적인 옵션입니다.

‘-I dir’
‘--include-dir=dir’
Specifies a directory dir to search for included makefiles. See Including Other Makefiles. If several ‘-I’ options are used to specify several directories, the directories
are searched in the order specified.

make clean 	오브젝트파일만 삭제
make fclean 	오브젝트파일과 타겟파일 삭제
make re		make fclean 후 다시 all

참조, 출처: https://bowbowbow.tistory.com/12#make-와-makefile [멍멍멍]
