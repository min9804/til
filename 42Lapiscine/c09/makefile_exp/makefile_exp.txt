-makefile_explain

소스파일을 컴파일을 하기위해서는 
gcc [옵션] [실행파일명] [소스파일명] 이 필요하다.

하지만 여러 파일을 컴파일 할 경우 각 소스 파일을 각각
.o 파일 오브젝트 파일로 만든 후 오브젝트 파일을 실행 파일로 만든다.

ex)
gcc -c hello.c
gcc -c main.c
gcc -o hello hello.o main.o

gcc -o hello hello.c main.c 처럼
소스파일로도 컴파일 할 수 있는데 왜 오브젝트 파일을 만들까?
소스 파일이 100개가 있는 경우 소스 파일로 컴파일 한다면
소스파일 한개에 문제가 생겼을 때 100개의 파일을 모두 다시 컴파일
해야한다. 이렇게 된다면 시간이 오래 걸리기 때문에 
각각의 오브젝트 파일을 만들어 놓고 수정할 소스가 생기면 수정후 
그 파일의 오브젝트 파일만 다시 만들면 된다.

위에 예 처럼 세줄을 쓰면서 컴파일 한다
너무 취찮으니까 만든 방법이 shellscript를 만들 수 있음

vim compile.sh파일

#!/bin/bash
gcc -c hello.c
gcc -c main.c
gcc -o hello hello.o main.o

chmod 755로 권한주기!
./copile.sh 하면 위에 3개의 명령어가 실행되면서 컴파일 된다.

하지만 shellscript를 작성해도 모든 소스파일을 오브젝트 파일로 만드는
과정을 거치게 된다. 이러면 또 시간이 오래 걸리기 때문에 이점이 없다.

이를 해결 하기 위해 makefile을 만들고 make프로그램을 이용한다.
make를 이용하면 변경된 소스만 오브젝트파일을 만들어 컴파일 하는
기능을 이용할 수 있다.


-Makefile 작성규칙

목표파일: 목표파일을 만드는데 필요한 구성요소들
(tab)	목표를 달성하기 위한 명령1
(tab)	목표를 달성하기 위한 명령2

//매크로 정의: Makdefile에 정의한 string으로 치환한다.
//명령어의 시작은 반드시 탭으로 시작한다.
//Dependency가 없는 target도 사용 가능하다.


-Make 예제

(타켓절)      (의존성)
hello_world : hello.o world.o main.o
	gcc -o hello_world hello.o world.o main.o (명령어)

hello.o : hello.c
	gcc -c -o hello.o hello.c

world.o : world.c
	gcc -c -o world.o world.c

main.o : main.c
	gcc -c -o main.o main.c

clean :			(더미타겟)
	rm *.o hello_world 

더미타겟은 파일을 생성하지 않는 개념적인 타겟으로 
make clean 명령하면 현재 디렉토리의 모든 object파일들과 생성된 실행
파일을 rm 명령어로 제거해 줍니다. 


-Makefile 매크로 사용

CC = 
