***
groups $FT_USER | tr ' ' ',' | tr -d '\n'

groups : 현재 사용자가 속해 있는 그룹을 확인
groups [계정명] : 계정이 속해있는 그룹 확인



***
NAME:
	groups - print the groups a user is in
SYNOPSIS:
	groups [OPTION]... [USERNAME]...

which help to bouild the beggining of the command:
$ groups $FT_USER

환경변수 FT_USER=nours 인경우 nours 가 어떤 그룹에 속해있는지 보여줌
환경변수 FT_USER=daemon 인경우 daemon 가 어떤 그룹에 속해있는지 보여줌



***
Next to make it a comma-separated list we need man tr and:
NAME:
	tr - translate or delete characters
SYNOPSIS:
	tr [OPTION]... SET1 [SET2]
DESCRIPTION:
	Translate, squeeze, and/or delete characters from standard input, writing to
	standard output.
	-d, --delete
		delete characters in SET1, do not translate

In this case as the description suggest we we only need one [OPTION], because with the output of groups $FT_USER that translate to all the groups that the FT_USER belong to, separated by a space and ending with a new line division on the output, we only need to replace the SPACES for COMAS, and delete the ending with \n. So we end up with this:

$ tr ' ' ','  :  ' ' 를 ',' 로 바꿈
$ tr -d '\n'  :  -d Delete characters in string1 from the input

$>./print_groups.sh
god,root,admin,master,nours,bocal$>
위와 같이 groups을 실행하고 개행문자가 없고 바로 명령어를 받기 때문에
개행 문자를 지워줘야 한다.



***
Pipeline
Now we'll take a look at a mechanism for sending data from one program to another. It's called piping and the operator we use is ( | ) (found above the backslash ( \ ) key on most keyboards). What this operator does is feed the output from the program on the left as input to the program on the right. In the example below we will list only the first 3 files in the directory.

$ ls
barry.txt bob example.png firstfile foo1 myoutput video.mpeg
$ ls | head -3
barry.txt
bob
example.png
$

| Pipe 뜻
* 왼쪽 명령어의 결과(output)을 오른쪽에 있는 명령어에 입력(input)으로 전달합니다.
* 즉, 좌측의 stdout을 우측의 stdin으로 된다고 생각하면 된다.

> Redirect 뜻
* 왼쪽 명령어의 결과(output)를 text.txt파일에 남깁니다.
* 즉, 좌측의 stdout을 우측의 파일에 남깁니다.
